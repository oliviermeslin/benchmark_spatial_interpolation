---
title: "Benchmark Algorithm of Ensemblist Methods on Spatial Data"
author:
  - "Bianco Andrea"
  - "Mancini Matteo"
  - "Mellot Rodrigue"
date: last-modified

format:
  html:
    toc: true
    number-sections: true
  pdf:
    documentclass: article
    papersize: a4
    number-sections: true
    colorlinks: true
    fig-pos: "H"

jupyter: python3
bibliography: references.bib

execute:
  enabled: true
---

# Abstract

Brief summary of the project, including: - the spatial interpolation problem, - the benchmarked methods, - the experimental design, - the main empirical results, - and the key conclusions.

# Introduction

All of the work produced in this report is being made with a fix seed equal to 42.

## Context

Introduce the spatial interpolation problem and its importance in environmental and geospatial applications.

## Research Question

Which algorithms perform best for spatial interpolation under different data-generating conditions?

## Motivation

Explain why comparing classical, geostatistical and machine learning approaches is relevant.

## Main Contributions

Summarize the main empirical and methodological contributions of the report.

## Structure of the Report

Brief description of the structure of the report.

# Datasets

There will be 8 datasets to cover combinations of:

-   **Real or Synthetic**
-   **Large or Small**
-   **Grid or No Grid**

For the **synthetic ones**, they are built following the idea that we need some data spatially correlated, be able to respect our different criteria:

-   **Spatial Correlation**: We use a **Matérn covariance model** (dimension=2, variance=1, length scale=10) to generate a Stationary Random Field (SRF). This ensures the synthetic data mimics the spatial continuity and "smoothness" often found in real-world environmental phenomena.
-   **Structure**: If there is a grid, points are generated on a regular Cartesian grid using a meshgrid of and coordinates. If it's not the case, points are sampled using a\*Uniform Random Distribution across the spatial domain to simulate irregular sampling.
-   **Size**: Ranging from 10,000 points for "Small" Datasets to 1,000,000 points for "Large" datasets
-   **Consistency**: A fixed seed (20170519) is applied to both the random field generation and the coordinate sampling to ensure the experiments are fully reproducible across different benchmark runs.

For the **real datasets**, we utilize high-quality topographic data provided by the **IGN (Institut National de l'Information Géographique et Forestière)**, the French national mapping agency.

-   **BD ALTI**: This dataset represents the "unstructured" real-world scenario. The points are derived from various sources (photogrammetry, digitization, etc.) where the spatial distribution of samples is irregular. So we can use this dataset as our no grid, large, real dataset.
-   **RGE ALTI**: It is the highest resolution elevation model available nationally. It is provided as a 5-meter regular grid. The full national dataset contains over 22 billion points. So we can use this dataset as our grid, large, real dataset.

For the Small real-world datasets, we use a subset of the French territory by filtering for Department 48 (Lozère). This department was chosen because its diverse topography—ranging from deep canyons and plateaus to mountainous terrain—offers a representative sample of various geographic challenges for spatial interpolation.

### Dataset Reference Table

| Dataset Name | Origin | Size Category | Structure | Approx. Row Count | Description |
|------------|------------|------------|------------|------------|------------|
| **bdalti** | Real | Large | No Grid | \~7,000,000 | BDALTI dataset. |
| **bdalti_48** | Real | Small | No Grid | \~400,000 | Department 48 (Lozère) subset of BDALTI. |
| **rgealti** | Real | Large | Grid | \~22,000,000,000 | RGEALTI. |
| **rgealti_48** | Real | Small | Grid | \~150,000 | Department 48 subset of RGEALTI. |
| **S-G-Sm** | Synthetic | Small | Grid | 10,000 | Structured Grid. |
| **S-G-Lg** | Synthetic | Large | Grid | 1,000,000 | Structured Grid. |
| **S-NG-Sm** | Synthetic | Small | No Grid | 10,000 | 10k points, Uniform Random Distribution. |
| **S-NG-Lg** | Synthetic | Large | No Grid | 1,000,000 | 1M points, Uniform Random Distribution. |

\*\* Note: For the full RGEALTI, the script currently uses a `.head(1_000_000)` limit to manage the massive 22-billion-row source file.\*

# Methodology

## General Framework

Overview of the benchmarking framework and experimental pipeline.

## Algorithms Considered

|  |  |
|----------------------------------------|--------------------------------|
| A\) Generalized Additive Models (GAM) | F\) Nearest Neighbor Interpolation |
| B\) GeoSpatial Random Forest | G\) Oblique Random Forest |
| C\) Gradient Boosting (HistGradientBoosting) | H\) Ordinary Kriging |
| D\) Inverse Distance Weighting (IDW) | I\) Random Forest |
| E\) MixGBoost | J\) XGBoost |

## Conceptual Comparison of Methods

Discussion of: - Deterministic vs geostatistical vs machine learning methods\
- Local vs global approaches\
- Computational complexity\
- Interpretability

## Coordinate Rotation

### Motivation

Tree-based models rely on axis-aligned splits, which are suboptimal for spatial data.

### Method

Application of coordinate rotations to enable oblique decision boundaries.

### Mathematical Formulation

$$
x' = x \cos(\theta) - y \sin(\theta)
$$

$$
y' = x \sin(\theta) + y \cos(\theta)
$$

### Implementation Details

-   Number of rotations\
-   Distribution of angles

## Evaluation Metrics

-   $R^2$\
-   RMSE\
-   MAE\
-   Training time

## Experimental Setup

-   Train/test split\
-   Random seed\
-   Preprocessing steps\
-   Hardware and software environment

# Results
```{python}
#| echo: false
import json
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
from pathlib import Path

# ============================================================================
# CONFIGURATION
# ============================================================================

# Set style
sns.set_style("whitegrid")
plt.rcParams['figure.dpi'] = 300
plt.rcParams['font.size'] = 10
plt.rcParams['axes.labelsize'] = 11
plt.rcParams['axes.titlesize'] = 12
plt.rcParams['xtick.labelsize'] = 9
plt.rcParams['ytick.labelsize'] = 9

# Load data
with open('example.json', 'r') as f:
    data = json.load(f)

results = data['results']

# Define datasets and model groups
datasets = ['rgealti', 'bdalti', 'bdalti_48', 'rgealti_48', 'S-G-Sm', 'S-G-Lg', 'S-NG-Sm', 'S-NG-Lg']

# Model groupings
deterministic_models = ['knn_3', 'idw_p3']
geostatistical_models = ['kriging']
tree_models = ['random_forest', 'random_forest_cr', 'xgboost', 'xgboost_cr', 'mixgboost', 'mixgboost_cr']
advanced_tree_models = ['oblique_rf', 'geoRF']
gam_models = ['gam', 'gam_cr']

# Model display names
model_names = {
    'random_forest': 'RF',
    'random_forest_cr': 'RF-CR',
    'xgboost': 'XGB',
    'xgboost_cr': 'XGB-CR',
    'mixgboost': 'MixGB',
    'mixgboost_cr': 'MixGB-CR',
    'oblique_rf': 'Oblique RF',
    'geoRF': 'GeoRF',
    'knn_3': 'KNN-3',
    'idw_p3': 'IDW-p3',
    'kriging': 'Kriging',
    'gam': 'GAM',
    'gam_cr': 'GAM-CR'
}

# Dataset display names
dataset_names = {
    'rgealti': 'RGE ALTI',
    'bdalti': 'BD ALTI',
    'bdalti_48': 'BD ALTI 48',
    'rgealti_48': 'RGE ALTI 48',
    'S-G-Sm': 'Synth Grid Small',
    'S-G-Lg': 'Synth Grid Large',
    'S-NG-Sm': 'Synth No-Grid Small',
    'S-NG-Lg': 'Synth No-Grid Large'
}

# Color schemes
color_deterministic = '#2E86AB'
color_geostat = '#A23B72'
color_tree = '#F18F01'
color_advanced_tree = '#C73E1D'
color_gam = '#6A994E'

def get_model_color(model):
    """Get color for a model based on its family"""
    if model in deterministic_models:
        return color_deterministic
    elif model in geostatistical_models:
        return color_geostat
    elif model in tree_models:
        return color_tree
    elif model in advanced_tree_models:
        return color_advanced_tree
    elif model in gam_models:
        return color_gam
    return '#888888'
```

## Overall Performance

Global comparison of all algorithms across datasets.

## Results by Algorithm Family

### Deterministic Methods

Analysis of IDW and nearest-neighbor interpolation.

### Geostatistical Methods

Analysis of Ordinary Kriging and related findings.

### Tree-Based Machine Learning Methods

Performance of Random Forest, Gradient Boosting, XGBoost and MixGBoost.

### Advanced Spatial Tree Methods

GeoSpatial RF and Oblique RF results.

### Generalized Additive Models

Performance and computational considerations.

## Cross-Dataset Analysis

### Effect of Coordinate Rotation

Comparison of results with and without rotation.

### Grid vs No-Grid Datasets

Impact of spatial structure on performance.

### Scalability

Performance comparison on small vs large datasets.

# Discussion

## Interpretation of Results

Explanation of observed performance patterns.

## Practical Implications

Guidelines for practitioners choosing interpolation methods.

## Limitations

Discussion of methodological and computational limitations.

## Future Work

Possible extensions and improvements.

# Conclusion

Summary of key findings and contributions.

# References

All references cited in the report.

# Appendix A: Detailed Results

## Synthetic Small Grid

Detailed tables and figures.

## Synthetic Small No-Grid

Detailed tables and figures.

## Synthetic Large Grid

Detailed tables and figures.

## Synthetic Large No-Grid

Detailed tables and figures.

## Real Small Datasets

Detailed tables and figures.

## Real Large Datasets

Detailed tables and figures.

# Appendix B: Algorithm Parameters

Detailed hyperparameter settings for each algorithm.